import express from "express";
import { exec } from "child_process";
import { promisify } from "util";
import dotenv from "dotenv";
import basicAuth from "basic-auth";
import cors from "cors";
import fs from "fs";
import https from "https";
import http from "http";

const execPromise = promisify(exec);
dotenv.config();

const app = express();
const PORT = process.env.PROXY_PORT || process.env.PORT || 8085;

// Check for YouTube cookies
const cookiesPath = process.env.YOUTUBE_COOKIES_FILE || './youtube-cookies.txt';
const hasCookies = fs.existsSync(cookiesPath);

if (hasCookies) {
  console.log(`âœ… Found YouTube cookies at ${cookiesPath}`);
  
  // Show cookie age
  const stats = fs.statSync(cookiesPath);
  const ageHours = (Date.now() - stats.mtime.getTime()) / 1000 / 60 / 60;
  const ageDays = Math.floor(ageHours / 24);
  console.log(`ðŸ“… Cookie age: ${ageDays} days (${Math.floor(ageHours)} hours)`);
  
  if (ageDays > 180) {
    console.warn('âš ï¸ Cookies are older than 6 months - consider refreshing them');
    console.warn('   Run: ./extract-youtube-cookies.sh safari');
  }
} else {
  console.warn('âš ï¸ No cookies file found. Videos may fail due to YouTube bot detection.');
  console.warn('   Run: ./extract-youtube-cookies.sh safari');
}

// In-memory video store (use Redis/DB for persistence)
let videos = [
  { id: "GMtfScXZ118", title: "Aquatiq BioMap", addedAt: new Date().toISOString() }
];

// Health metrics tracking
const metrics = {
  totalStreams: 0,
  successfulStreams: 0,
  failedStreams: 0,
  errors: {
    403: 0,
    429: 0,
    500: 0,
    bot_detection: 0
  },
  lastCookieRefresh: hasCookies ? fs.statSync(cookiesPath).mtime : null,
  startTime: new Date(),
  activeStreams: new Set()
};

// Enable CORS for dashboard communication
app.use(cors());
app.use(express.json());

// Multer for file uploads (in-memory)
import multer from 'multer';
const upload = multer({ storage: multer.memoryStorage() });

// Optional basic auth middleware
function maybeAuth(req, res, next) {
  const user = process.env.BASIC_AUTH_USER;
  const pass = process.env.BASIC_AUTH_PASS;
  if (!user || !pass) return next();

  const credentials = basicAuth(req);
  if (!credentials || credentials.name !== user || credentials.pass !== pass) {
    res.setHeader("WWW-Authenticate", "Basic realm=\"YouTube Proxy\"");
    return res.status(401).send("Authentication required");
  }
  return next();
}

app.get("/", (req, res) => {
  res.send("âœ… Aquatiq YouTube Proxy is running");
});

app.get("/health", (req, res) => {
  res.json({
    status: "ok",
    pid: process.pid,
    uptime: process.uptime(),
    videoCount: videos.length,
    hasCookies: hasCookies,
    timestamp: new Date().toISOString(),
  });
});

// API: Get video list
app.get("/api/videos", (req, res) => {
  res.json({ videos });
});

// API: Add video
app.post("/api/videos", (req, res) => {
  const { id, title } = req.body;
  if (!id) return res.status(400).json({ error: "Missing video id" });

  const existingVideo = videos.find((v) => v.id === id);
  if (existingVideo) {
    return res.status(400).json({ error: "Video already exists" });
  }

  const newVideo = {
    id,
    title: title || `Video ${id}`,
    addedAt: new Date().toISOString(),
  };

  videos.push(newVideo);
  res.json({ success: true, video: newVideo });
});

// API: Remove video
app.delete("/api/videos/:id", (req, res) => {
  const { id } = req.params;
  const index = videos.findIndex((v) => v.id === id);

  if (index === -1) {
    return res.status(404).json({ error: "Video not found" });
  }

  videos.splice(index, 1);
  res.json({ success: true });
});

// API: Upload YouTube cookies
app.post("/api/cookies/upload", upload.single('cookies'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: "No cookies file uploaded" });
    }

    // Write cookies to file
    fs.writeFileSync(cookiesPath, req.file.buffer.toString('utf-8'));
    console.log(`âœ… Cookies updated (${req.file.size} bytes)`);
    
    res.json({ 
      success: true, 
      message: "Cookies updated successfully",
      size: req.file.size 
    });
  } catch (err) {
    console.error("Error uploading cookies:", err.message);
    res.status(500).json({ error: err.message });
  }
});

// API: Update cookies from JSON (for browser extension)
app.post("/api/cookies/update", async (req, res) => {
  try {
    const { cookies } = req.body;
    
    if (!cookies || !Array.isArray(cookies)) {
      return res.status(400).json({ error: "Invalid cookies format. Expected array of cookie objects." });
    }

    // Convert cookies to Netscape format
    let netscapeCookies = "# Netscape HTTP Cookie File\n";
    netscapeCookies += "# This file is generated by Aquatiq Digital Signage. Do not edit.\n\n";
    
    cookies.forEach(cookie => {
      // Netscape format: domain, flag, path, secure, expiration, name, value
      const domain = cookie.domain || '.youtube.com';
      const flag = domain.startsWith('.') ? 'TRUE' : 'FALSE';
      const path = cookie.path || '/';
      const secure = cookie.secure ? 'TRUE' : 'FALSE';
      const expiration = cookie.expirationDate ? Math.floor(cookie.expirationDate) : 0;
      const name = cookie.name;
      const value = cookie.value;
      
      netscapeCookies += `${domain}\t${flag}\t${path}\t${secure}\t${expiration}\t${name}\t${value}\n`;
    });

    // Write to file
    fs.writeFileSync(cookiesPath, netscapeCookies);
    console.log(`âœ… Cookies updated from browser (${cookies.length} cookies)`);
    
    res.json({ 
      success: true, 
      message: `Updated ${cookies.length} cookies`,
      count: cookies.length 
    });
  } catch (err) {
    console.error("Error updating cookies:", err.message);
    res.status(500).json({ error: err.message });
  }
});

// API: Get cookies status
app.get("/api/cookies/status", (req, res) => {
  try {
    if (!fs.existsSync(cookiesPath)) {
      return res.json({ 
        hasCookies: false, 
        message: "No cookies file found" 
      });
    }

    const stats = fs.statSync(cookiesPath);
    const content = fs.readFileSync(cookiesPath, 'utf-8');
    const cookieCount = content.split('\n').filter(line => line && !line.startsWith('#')).length;
    
    res.json({ 
      hasCookies: true,
      count: cookieCount,
      size: stats.size,
      modified: stats.mtime,
      age: Math.floor((Date.now() - stats.mtime.getTime()) / 1000 / 60), // minutes
      ageDays: Math.floor((Date.now() - stats.mtime.getTime()) / 1000 / 60 / 60 / 24),
      recommendRefresh: Math.floor((Date.now() - stats.mtime.getTime()) / 1000 / 60 / 60 / 24) > 180
    });
  } catch (err) {
    console.error("Error getting cookies status:", err.message);
    res.status(500).json({ error: err.message });
  }
});

// API: Get video info
app.get("/api/info", async (req, res) => {
  const id = req.query.v;
  if (!id) return res.status(400).json({ error: "Missing video id (?v=...)" });

  try {
    const cookiesArg = hasCookies ? `--cookies ${cookiesPath}` : '';
    const cmd = `yt-dlp ${cookiesArg} --dump-json "https://www.youtube.com/watch?v=${id}"`;
    const { stdout } = await execPromise(cmd);
    const info = JSON.parse(stdout);
    
    res.json({
      id,
      title: info.title,
      duration: info.duration,
      thumbnail: info.thumbnail,
      author: info.uploader || info.channel,
    });
  } catch (err) {
    console.error("Error fetching video info:", err.message);
    res.status(500).json({ error: err.message });
  }
});

// Main streaming endpoint: /stream?v=GMtfScXZ118
app.get("/stream", maybeAuth, async (req, res) => {
  const id = req.query.v;
  if (!id) return res.status(400).send("Missing video id (?v=...)");

  const streamId = `${id}-${Date.now()}`;
  metrics.totalStreams++;
  metrics.activeStreams.add(streamId);

  try {
    // Try without cookies first using android client (often works without auth)
    let cmd = `yt-dlp --extractor-args "youtube:player_client=android" -f "bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best" --get-url "https://www.youtube.com/watch?v=${id}"`;
    
    console.log(`Fetching stream URL for video: ${id}`);
    let result;
    try {
      result = await execPromise(cmd);
    } catch (err) {
      // If android client fails, try with cookies
      if (hasCookies) {
        console.log(`Retrying with cookies...`);
        cmd = `yt-dlp --cookies ${cookiesPath} --extractor-args "youtube:player_client=android,web" -f "bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best" --get-url "https://www.youtube.com/watch?v=${id}"`;
        result = await execPromise(cmd);
      } else {
        throw err;
      }
    }
    
    const { stdout } = result;
    const streamUrl = stdout.trim().split('\n')[0]; // Get first URL (video)
    
    if (!streamUrl) {
      metrics.failedStreams++;
      metrics.errors[404] = (metrics.errors[404] || 0) + 1;
      return res.status(404).send("No stream URL found");
    }

    console.log(`Proxying stream from: ${streamUrl.substring(0, 100)}...`);

    // Proxy the stream with range support
    const protocol = streamUrl.startsWith('https:') ? https : http;
    
    const headers = {};
    if (req.headers.range) {
      headers['Range'] = req.headers.range;
    }

    const proxyReq = protocol.get(streamUrl, { headers }, (proxyRes) => {
      // Track successful stream start
      if (proxyRes.statusCode === 200 || proxyRes.statusCode === 206) {
        metrics.successfulStreams++;
        console.log(`âœ… Stream started successfully for ${id}`);
      }
      
      // Forward status code
      res.status(proxyRes.statusCode);
      
      // Forward important headers
      ['content-type', 'content-length', 'content-range', 'accept-ranges'].forEach(header => {
        if (proxyRes.headers[header]) {
          res.setHeader(header, proxyRes.headers[header]);
        }
      });

      // Add caching and CORS headers
      res.setHeader('Cache-Control', 'public, max-age=3600');
      res.setHeader('Access-Control-Allow-Origin', '*');
      
      // Pipe the stream
      proxyRes.pipe(res);
    });

    proxyReq.on('error', (err) => {
      console.error('Proxy request error:', err.message);
      metrics.failedStreams++;
      metrics.errors[500] = (metrics.errors[500] || 0) + 1;
      metrics.activeStreams.delete(streamId);
      if (!res.headersSent) {
        res.status(500).send('Streaming error');
      }
    });

    // Handle client disconnect
    req.on('close', () => {
      proxyReq.destroy();
      metrics.activeStreams.delete(streamId);
      console.log(`Client disconnected from video: ${id}`);
    });

  } catch (err) {
    console.error("Proxy error:", err.message);
    metrics.failedStreams++;
    metrics.activeStreams.delete(streamId);
    
    // Track specific error types
    if (err.message.includes('Sign in') || err.message.includes('bot')) {
      metrics.errors.bot_detection++;
    } else if (err.message.includes('403')) {
      metrics.errors[403]++;
    } else if (err.message.includes('429')) {
      metrics.errors[429]++;
    } else {
      metrics.errors[500]++;
    }
    
    // Give helpful error messages
    let errorMsg = err.message;
    if (errorMsg.includes('Sign in') || errorMsg.includes('bot')) {
      errorMsg = 'YouTube requires authentication. Please add cookies. See YOUTUBE_COOKIES_SETUP.md';
    }
    
    if (!res.headersSent) {
      res.status(500).send(`Error: ${errorMsg}`);
    }
  }
});

// Health metrics endpoint
app.get("/api/health", (req, res) => {
  const uptime = Date.now() - metrics.startTime.getTime();
  const cookieAge = metrics.lastCookieRefresh ? Math.floor((Date.now() - metrics.lastCookieRefresh.getTime()) / 1000 / 60 / 60 / 24) : null;
  
  res.json({
    status: "healthy",
    uptime: Math.floor(uptime / 1000), // seconds
    uptimeHuman: `${Math.floor(uptime / 1000 / 60 / 60)}h ${Math.floor((uptime / 1000 / 60) % 60)}m`,
    proxy: {
      totalStreams: metrics.totalStreams,
      successfulStreams: metrics.successfulStreams,
      failedStreams: metrics.failedStreams,
      activeStreams: metrics.activeStreams.size,
      successRate: metrics.totalStreams > 0 ? ((metrics.successfulStreams / metrics.totalStreams) * 100).toFixed(1) + '%' : 'N/A'
    },
    errors: metrics.errors,
    cookies: {
      exists: hasCookies,
      age: cookieAge,
      ageHuman: cookieAge ? `${cookieAge} days` : 'N/A',
      needsRefresh: cookieAge ? cookieAge > 180 : false,
      lastRefresh: metrics.lastCookieRefresh ? metrics.lastCookieRefresh.toISOString() : null
    },
    timestamp: new Date().toISOString()
  });
});

app.listen(PORT, () => console.log(`ðŸŽ¬ Aquatiq Proxy running on port ${PORT}`));
